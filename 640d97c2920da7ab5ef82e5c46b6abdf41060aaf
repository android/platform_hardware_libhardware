{
  "comments": [
    {
      "key": {
        "uuid": "274e5eac_bccc16e6",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 84,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-13T23:01:54Z",
      "side": 1,
      "message": "Why not describe all the arguments.",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "676db610_627dbbfb",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 84,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-14T22:31:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "274e5eac_bccc16e6",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c75ca266_5876b4ba",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-13T23:01:54Z",
      "side": 1,
      "message": "This api does not seem to support a large number of entries. What is the expected use of this api? It seems to only return a set of numbers with no additional information about what they are used for.",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e759a674_2b828370",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-14T22:31:14Z",
      "side": 1,
      "message": "We expect \u003c 10 spaces. I\u0027ve intentionally left this API agnostic to specific index values, but the intent is that they are defined at compile time in another file so device developers don\u0027t need to change the HAL to add an index.",
      "parentUuid": "c75ca266_5876b4ba",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "27673e34_1e36eabb",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 131,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-13T23:01:54Z",
      "side": 1,
      "message": "how does a client determine what value should be passed here (and everywhere else that takes an index)",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "274e5eac_2efc4988",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 131,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-14T22:31:14Z",
      "side": 1,
      "message": "[See above]. The intent is that these index values are well-defined at compile time (elsewhere) and clients know which values they want to use work with.",
      "parentUuid": "27673e34_1e36eabb",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "274e5eac_3c27665c",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-13T23:01:54Z",
      "side": 1,
      "message": "I would avoid pointers to enums in your api, as the size of enums can change between compilers and compiler options.",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "274e5eac_ce6fa5ff",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-14T22:31:14Z",
      "side": 1,
      "message": "Is this a realistic concern? Wouldn\u0027t every int and every struct that contains an int / enum also have problems? I think ABI compatible toolchains for all components in the same system needs to be a given. Of course, the field size needs to be exact for marshaling or persisting the value but that\u0027s not the case here.\n\nAll that said, enums are widely used in other HAL APIs and I\u0027d like to keep that consistent here. Do you know instances where other HALs have had this sort of issue in the past?",
      "parentUuid": "274e5eac_3c27665c",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "07623a24_6beabc5b",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-14T23:19:49Z",
      "side": 1,
      "message": "enum are not comparable to ints. Some compilers will change the size if the enum based on the largest value defined. The size of an int is defined by the abi.",
      "parentUuid": "274e5eac_ce6fa5ff",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8780ea14_8a264b92",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1080683
      },
      "writtenOn": "2016-01-18T08:50:02Z",
      "side": 1,
      "message": "I concur with Arve. The standard says the compiler may choose an integer type of any width provided it can hold all valid enum values. This impacts the size of array elements, which would break the API if provider and consumer disagree on sizeof(nvaram_control_t).\n\nI think it\u0027s conceivable that compilers may make different choices, in particular choosing either uint32_t or uint64_t depending on whatever is considered to be faster w.r.t. to register width or whatnot.\n\nOn a slightly related note, if this were C++ you could just use a scoped enum type and declare the width explicitly, i.e.\n\nenum class nvram_control_t : uint32_t { ... }",
      "parentUuid": "07623a24_6beabc5b",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "27673e34_cfa957b5",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-19T17:35:03Z",
      "side": 1,
      "message": "Done -- I\u0027ve made these types uint32_t and declared constants.",
      "parentUuid": "8780ea14_8a264b92",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "07495aa4_6722fd4c",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 175,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-13T23:01:54Z",
      "side": 1,
      "message": "OK, but how do you find the same space again later if you dynamically allocated an index.",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "678e9643_7ff55072",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 175,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-14T22:31:14Z",
      "side": 1,
      "message": "I have no intention to support dynamic index allocation. Making this API agnostic to index values does make it possible, however. If we did support it there would have to be some kind of central index manager, like keystore provides for keys. I\u0027d rather just not go there for now.",
      "parentUuid": "07495aa4_6722fd4c",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e798c691_68ba9789",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 175,
      "author": {
        "id": 1080683
      },
      "writtenOn": "2016-01-18T08:50:02Z",
      "side": 1,
      "message": "Note that get_space_list is provided in the API, so you can find existing spaces that have been dynamically allocated previously.",
      "parentUuid": "678e9643_7ff55072",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c75ca266_984e8c6f",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 218,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-13T23:01:54Z",
      "side": 1,
      "message": "who calls this, and how does it work with multiple clients.",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4768b202_26fc7688",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 218,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-14T22:31:14Z",
      "side": 1,
      "message": "This is designed to allow enforcement of a one-time setup / enrollment / registration stage, after which we have confidence the spaces we access were setup before that stage closed.\n\nIt affects all clients.",
      "parentUuid": "c75ca266_984e8c6f",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "07495aa4_47cb81a1",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 229,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-13T23:01:54Z",
      "side": 1,
      "message": "0xff is not compatible with normal filesystems. It would be better to use 0 here.",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "676db610_647b08a0",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 229,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-14T22:31:14Z",
      "side": 1,
      "message": "How is it incompatible? Filesystems should be agnostic to the data in files, no? \n\nUsing 0xFF is an attempt to reduce erase cycles on some types of flash -- apart from that it\u0027s arbitrary. Is there any kind of performance or convenience advantage to using 0?",
      "parentUuid": "07495aa4_47cb81a1",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e759a674_2ed73174",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 229,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-14T23:19:49Z",
      "side": 1,
      "message": "From the truncate man page:\n       If the file previously was larger than this size, the extra data is lost.   If  the  file  previously  was\n       shorter, it is extended, and the extended part reads as null bytes (\u0027\\0\u0027).\n\nI have no plan to make secure storage in trusty have any other behavior if we allow growing the file size without writing data to it.",
      "parentUuid": "676db610_647b08a0",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e798c691_48b7d39f",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 229,
      "author": {
        "id": 1080683
      },
      "writtenOn": "2016-01-18T08:50:02Z",
      "side": 1,
      "message": "NVRAM space size is determined at creation time, so truncate behavior is not a concern. FWIW, my implementation on top of secure storage didn\u0027t run into issues in this regard.\n\nIn general, I don\u0027t think it makes a practical implementation difference as to what value the space contents start out with, at least as long as you can write multiple times to the same space (hence an implementation can always perform an implicit write at creation time to initialize the space contents appropriately). However, I do feel strong that we should mandate initialization, as this will reduce surprises in case consumers unintentionally rely on uninitialized space contents.",
      "parentUuid": "e759a674_2ed73174",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "07495aa4_5ca50771",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 229,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-19T17:35:03Z",
      "side": 1,
      "message": "Changed to 0 in the design doc and here.",
      "parentUuid": "e798c691_48b7d39f",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4768b202_92faed5f",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 230,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-13T23:01:54Z",
      "side": 1,
      "message": "are only complete updates supported?",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c75ca266_8ca3eacb",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 230,
      "author": {
        "id": 1079236
      },
      "writtenOn": "2016-01-14T22:31:14Z",
      "side": 1,
      "message": "Yes. Typically the data in these spaces is just a hash or otherwise very small so this is an easy way to reduce complexity.",
      "parentUuid": "4768b202_92faed5f",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e759a674_1560830a",
        "filename": "include/hardware/nvram.h",
        "patchSetId": 2
      },
      "lineNbr": 247,
      "author": {
        "id": 1000205
      },
      "writtenOn": "2016-01-13T23:01:54Z",
      "side": 1,
      "message": "See above.",
      "revId": "640d97c2920da7ab5ef82e5c46b6abdf41060aaf",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}